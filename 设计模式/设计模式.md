## 设计模式
### 设计原则
* 单一职责原则（SRP）
一个对象或方法只做一件事情。如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。
应该把对象或方法划分成较小的粒度

* 最少知识原则（LKP）
一个软件实体应当 尽可能少地与其他实体发生相互作用 
应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的 相互联系，可以转交给第三方进行处理
* 开放-封闭原则（OCP）
软件实体（类、模块、函数）等应该是可以 扩展的，但是不可修改
当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，尽量避免改动程序的源代码，防止影响原系统的稳定
### 单例模式
* 单保证一个类仅有一个实例，并提供一个访问它的全局访问点
* 场景<br>
   单例模式是一种常用的模式，有一些对象我们往往只需要一个，比如全局缓存、浏览器的window对象。
> 1、可以用它来划分命名空间
> 2、借助单例模式，可以把代码组织的更为一致，方便阅读与维护

### 工厂模式
* 工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。
* 应用场景
> 对象的构建十分复杂<br>
> 需要依赖具体环境创建不同实例<br>
> 处理大量具有相同属性的小对象<br>
* 优点
> 1、弱化对象间的耦合，防止代码的重复。在一个方法中进行类的实例化，可以消除重复性的代码。<br>
> 2、重复性的代码可以放在父类去编写，子类继承于父类的所有成员属性和方法，子类只专注于实现自己的业务逻辑。<br>
* 缺点
> 当工厂增加到一定程度的时候，提升了代码的复杂度，可读性下降。而且没有解决对象的识别问题，即怎么知道一个对象的类型。

### 观察者模式
* 定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新，也被称为是发布订阅模式。它需要一种高级的抽象策略，以便订阅者能够彼此独立地发生改变，而发行方能够接受任何有消费意向的订阅者。
* 应用场景
> 1. 确定谁是发布者(比如我的博客)。
> 2. 然后给发布者添加一个缓存列表，用于存放回调函数来通知订阅者。
> 3. 发布消息，发布者需要遍历这个缓存列表，依次触发里面存放的订阅者回调函数。
> 4、退订（比如不想再接收到这些订阅的信息了，就可以取消掉）
* 优点：当我们需要维护相关对象的一致性的时候，使用观察者模式，，就可以避免对象之间的紧密耦合。例如，一个对象可以通知另外一个对象，而不需要知道这个对象的信息。
* 缺点：在发布/订阅模式中，如果我们需要将发布者同订阅者上解耦，将会在一些情况下，导致很难确保我们应用中的特定部分按照我们预期的那样正常工作。也就是说它的优点也可能是它的缺点

### 策略模式
* 策略模式指的是定义一些列的算法，把他们一个个封装起来，目的就是将算法的使用与算法的实现分离开来。说白了就是以前要很多判断的写法，现在把判断里面的内容抽离开来，变成一个个小的个体。
* 使用场景<br>
策略模式最实用的场合就是某个“类”中包含有大量的条件性语句，比如if...else 或者 switch。每一个条件分支都会引起该“类”的特定行为以不同的方式作出改变。以其维护一段庞大的条件性语句，不如将每一个行为划分为多个独立的对象。每一个对象被称为一个策略。设置多个这种策略对象，可以改进我们的代码质量，也更好的进行单元测试。
* 优点：可以有效地避免多重条件语句，将一系列方法封装起来也更直观，利于维护
* 缺点：往往策略集会比较多，我们需要事先就了解定义好所有的情况

### 代理模式
* 为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。
* 优点
> 职责清晰，真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件完成事务，附带的结果就是编程简洁清晰。<br>
> 代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保护了目标对象的作用。<br>
> 高扩展性<br>

### 组合模式
* 组合模式，将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。掌握组合模式的重点是要理解清楚 “部分/整体” 还有 ”单个对象“ 与 "组合对象" 的含义。
组合模式可以让客户端像修改配置文件一样简单的完成本来需要流程控制语句来完成的功能。
* 优点：可以方便地构造一棵树来表示对象的部分-整体 结构。在树的构造最终 完成之后，只需要通过请求树的最顶层对 象，便能对整棵树做统一一致的操作。
* 缺点：创建出来的对象长得都差不多，可能会使代码不好理解，创建太多的对象对性能也会有一些影响
* 可以用树形结构来表示这种“部分- 整体”的层次结构。

### 装饰者模式
* 以动态地给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象。是一种“即用即付”的方式，能够在不改变对 象自身的基础上，在程序运行期间给对象动态地添加职责
* 核心：是为对象动态加入行为，经过多重包装，可以形成一条装饰链
* 优点：
> 1. Decorator模式与继承关系的目的都是要扩展对象的功能，但是Decorator可以提供比继承更多的灵活性。
> 2. 通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。
* 缺点：
> 1. 这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。<br>
> 2. 装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。<br>
> 3. 装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可以改变Component接口，增加新的公开的行为，实现“半透明”的装饰者模式。在实际项目中要做出最佳选择。<br>

### 状态模式
* 当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。状态模式主要解决的是当控制一个对象状态的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简化。
* 允许一个对象在其内部状态改变时改变它的行为
> 1.一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为。
> 2.一个操作中含有庞大的多分支结构，并且这些分支决定于对象的状态。


